var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  for (var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target, i = decorators.length - 1, decorator; i >= 0; i--)
    (decorator = decorators[i]) && (result = (kind ? decorator(target, key, result) : decorator(result)) || result);
  return kind && result && __defProp(target, key, result), result;
};

// src/workers/d1/database.worker.ts
import assert from "node:assert";
import {
  get,
  HttpError,
  MiniflareDurableObject,
  POST,
  viewToBuffer
} from "miniflare:shared";
import { z } from "miniflare:zod";
var D1ValueSchema = z.union([
  z.number(),
  z.string(),
  z.null(),
  z.number().array()
]), D1QuerySchema = z.object({
  sql: z.string(),
  params: z.array(D1ValueSchema).nullable().optional()
}), D1QueriesSchema = z.union([D1QuerySchema, z.array(D1QuerySchema)]), D1ResultsFormatSchema = z.enum(["ARRAY_OF_OBJECTS", "ROWS_AND_COLUMNS", "NONE"]).catch("ARRAY_OF_OBJECTS"), served_by = "miniflare.db", D1Error = class extends HttpError {
  constructor(cause) {
    super(500);
    this.cause = cause;
  }
  toResponse() {
    let response = { success: !1, error: typeof this.cause == "object" && this.cause !== null && "message" in this.cause && typeof this.cause.message == "string" ? this.cause.message : String(this.cause) };
    return Response.json(response);
  }
};
function convertParams(params) {
  return (params ?? []).map(
    (param) => (
      // If `param` is an array, assume it's a byte array
      Array.isArray(param) ? viewToBuffer(new Uint8Array(param)) : param
    )
  );
}
function convertRows(rows) {
  return rows.map(
    (row) => row.map((value) => {
      let normalised;
      return value instanceof ArrayBuffer ? normalised = Array.from(new Uint8Array(value)) : normalised = value, normalised;
    })
  );
}
function rowsToObjects(columns, rows) {
  return rows.map(
    (row) => Object.fromEntries(columns.map((name, i) => [name, row[i]]))
  );
}
function sqlStmts(db) {
  return {
    getChanges: db.prepare(
      "SELECT total_changes() AS totalChanges, last_insert_rowid() AS lastRowId"
    )
  };
}
var D1DatabaseObject = class extends MiniflareDurableObject {
  #stmts;
  constructor(state, env) {
    super(state, env), this.#stmts = sqlStmts(this.db);
  }
  #changes() {
    let changes = get(this.#stmts.getChanges());
    return assert(changes !== void 0), changes;
  }
  #query = (format, query) => {
    let beforeTime = performance.now(), beforeSize = this.state.storage.sql.databaseSize, beforeChanges = this.#changes(), params = convertParams(query.params ?? []), cursor = this.db.prepare(query.sql)(...params), columns = cursor.columnNames, rows = convertRows(Array.from(cursor.raw())), results;
    format === "ROWS_AND_COLUMNS" ? results = { columns, rows } : results = rowsToObjects(columns, rows);
    let afterTime = performance.now(), afterSize = this.state.storage.sql.databaseSize, afterChanges = this.#changes(), duration = afterTime - beforeTime, changes = afterChanges.totalChanges - beforeChanges.totalChanges, hasChanges = changes !== 0, lastRowChanged = afterChanges.lastRowId !== beforeChanges.lastRowId, changed = hasChanges || lastRowChanged || afterSize !== beforeSize;
    return {
      success: !0,
      results,
      meta: {
        served_by,
        duration,
        changes,
        last_row_id: afterChanges.lastRowId,
        changed_db: changed,
        size_after: afterSize,
        rows_read: cursor.rowsRead,
        rows_written: cursor.rowsWritten
      }
    };
  };
  #txn(queries, format) {
    if (queries = queries.filter(
      (query) => query.sql.replace(/^\s+--.*/gm, "").trim().length > 0
    ), queries.length === 0) {
      let error = new Error("No SQL statements detected.");
      throw new D1Error(error);
    }
    try {
      return this.state.storage.transactionSync(
        () => queries.map(this.#query.bind(this, format))
      );
    } catch (e) {
      throw new D1Error(e);
    }
  }
  queryExecute = async (req) => {
    let queries = D1QueriesSchema.parse(await req.json());
    Array.isArray(queries) || (queries = [queries]);
    let { searchParams } = new URL(req.url), resultsFormat = D1ResultsFormatSchema.parse(
      searchParams.get("resultsFormat")
    );
    return Response.json(this.#txn(queries, resultsFormat));
  };
};
__decorateClass([
  POST("/query"),
  POST("/execute")
], D1DatabaseObject.prototype, "queryExecute", 2);
export {
  D1DatabaseObject,
  D1Error
};
//# sourceMappingURL=database.worker.js.map
